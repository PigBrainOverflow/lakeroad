#lang errortrace racket
;;; Utilities for .btor files.

(provide parse-btor)

(require rosette)

(define (parse-btor str)

  ;;; Maps ids (number) to bv expressions.
  (define h (make-hash))
  (define (get id)
    (hash-ref h id))
  (define (get-str id-str)
    (get (string->number id-str)))

  (define ins (make-hash))
  (define outs (make-hash))

  (for ([line (filter (lambda (line) (not (equal? #\; (string-ref line 0))))
                      (string-split str #rx"\n+"))])
    (match-let* ;;; Remove comments.
     ([line (first (string-split line ";"))] [(cons id-str tokens) (string-split line)]
                                             [id (string->number id-str)])
     (match tokens
       [`("sort" "bitvec" ,width-str) (hash-set! h id (bitvector (string->number width-str)))]
       [`("input" ,type-id-str ,name)
        (let* ([type (hash-ref h (string->number type-id-str))]
               [const (constant (string->symbol name) type)])
          (hash-set! ins name const)
          (hash-set! h id const))]
       [`("const" ,type-id-str ,value-str)
        (let* ([type (hash-ref h (string->number type-id-str))] [value (string->number value-str 2)])
          (hash-set! h id (bv value type)))]
       [`("ite" ,type-id-str ,cond-id-str ,true-val-id-str ,false-val-id-str)
        (hash-set! h
                   id
                   (if (bitvector->bool (get-str cond-id-str))
                       (get-str true-val-id-str)
                       (get-str false-val-id-str)))]
       [`("slice" ,type-id-str ,val-id-str ,u-str ,l-str)
        (hash-set! h id (extract (string->number u-str) (string->number l-str) (get-str val-id-str)))]
       [`("output" ,id-str ,name)
        (hash-set! outs name (get-str id-str))
        (hash-set! h id name)]
       [`("uext" ,out-type-id-str ,in-id-str ,_ ...)
        (hash-set! h id (zero-extend (get-str in-id-str) (get-str out-type-id-str)))]
       [`("not" ,out-type-id-str ,in-id-str) (hash-set! h id (bvnot (get-str in-id-str)))]
       [`("eq" ,out-type-id-str ,a-id-str ,b-id-str)
        (hash-set! h
                   id
                   (bool->bitvector (bveq (get-str a-id-str) (get-str b-id-str))
                                    (get-str out-type-id-str)))]
       [`("and" ,out-type-id-str ,a-id-str ,b-id-str)
        (hash-set! h id (bvand (get-str a-id-str) (get-str b-id-str)))]
       [`("or" ,out-type-id-str ,a-id-str ,b-id-str)
        (hash-set! h id (bvor (get-str a-id-str) (get-str b-id-str)))]
       [`("xor" ,out-type-id-str ,a-id-str ,b-id-str)
        (hash-set! h id (bvxor (get-str a-id-str) (get-str b-id-str)))])))

  (list ins outs))

(module+ test
  (require rackunit
           rosette/solver/smt/boolector
           "lut.rkt"
           "interpreter.rkt")

  (current-solver (boolector))

  (test-case
   "Parse a LUT4 and verify its implementation against our lut function."
   (begin
     (match-define (list ins outs)
       (parse-btor
        #<<here-string-delimiter
; BTOR description generated by Yosys 0.15+50 (git sha1 6318db615, x86_64-apple-darwin20.2-clang 10.0.0-4ubuntu1 -fPIC -Os) for module LUT4.
1 sort bitvec 1
2 input 1 A ; myLUT4.v:2.19-2.20
3 input 1 B ; myLUT4.v:2.22-2.23
4 input 1 C ; myLUT4.v:2.25-2.26
5 input 1 D ; myLUT4.v:2.28-2.29
6 sort bitvec 16
7 input 6 INIT ; myLUT4.v:3.17-3.21
8 sort bitvec 8
9 slice 8 7 7 0
10 slice 8 7 15 8
11 ite 8 5 10 9
12 sort bitvec 4
13 slice 12 11 3 0
14 slice 12 11 7 4
15 ite 12 4 14 13
16 sort bitvec 2
17 slice 16 15 1 0
18 slice 16 15 3 2
19 ite 16 3 18 17
20 slice 1 19 0 0
21 slice 1 19 1 1
22 ite 1 2 21 20
23 output 22 Z ; myLUT4.v:2.38-2.39
24 uext 16 19 0 s1 ; myLUT4.v:7.16-7.18
25 uext 12 15 0 s2 ; myLUT4.v:6.16-6.18
26 uext 8 11 0 s3 ; myLUT4.v:5.16-5.18
; end of yosys output
here-string-delimiter
        ;
        ))

     (define A (hash-ref ins "A"))
     (define B (hash-ref ins "B"))
     (define C (hash-ref ins "C"))
     (define D (hash-ref ins "D"))
     (define INIT (hash-ref ins "INIT"))

     ;;; Verify the parsed LUT4 against our implementation of LUT.
     (check-true (unsat? (verify (assert (bveq (hash-ref outs "Z") (lut INIT (concat D C B A)))))))))

  (test-case
   "Parse a LUT4 and verify its implementation against our lut function."
   (begin
     (match-define (list ins outs)
       (parse-btor
        #<<here-string-delimiter
; BTOR description generated by Yosys 0.19+14 (git sha1 2326b9f90, clang 12.0.0 -fPIC -Os) for module CCU2C.
1 sort bitvec 1
2 input 1 A0 ; myCCU2C.v:17.25-17.27
3 input 1 A1 ; myCCU2C.v:17.41-17.43
4 input 1 B0 ; myCCU2C.v:17.29-17.31
5 input 1 B1 ; myCCU2C.v:17.45-17.47
6 input 1 C0 ; myCCU2C.v:17.33-17.35
7 input 1 C1 ; myCCU2C.v:17.49-17.51
8 input 1 CIN ; myCCU2C.v:17.20-17.23
9 input 1 D0 ; myCCU2C.v:17.37-17.39
10 input 1 D1 ; myCCU2C.v:17.53-17.55
11 sort bitvec 16
12 input 11 INIT0 ; myCCU2C.v:18.46-18.51
13 input 11 INIT1 ; myCCU2C.v:18.66-18.71
14 sort bitvec 64
15 input 14 INJECT1_0 ; myCCU2C.v:18.86-18.95
16 input 14 INJECT1_1 ; myCCU2C.v:18.110-18.119
17 sort bitvec 8
18 slice 17 13 7 0
19 slice 17 13 15 8
20 ite 17 10 19 18
21 sort bitvec 4
22 slice 21 20 3 0
23 slice 21 20 7 4
24 ite 21 7 23 22
25 sort bitvec 2
26 slice 25 24 1 0
27 slice 25 24 3 2
28 ite 25 5 27 26
29 slice 1 28 0 0
30 slice 1 28 1 1
31 ite 1 3 30 29
32 not 1 31
33 slice 25 13 1 0
34 slice 25 13 3 2
35 ite 25 5 34 33
36 slice 1 35 0 0
37 slice 1 35 1 1
38 ite 1 3 37 36
39 const 1 0
40 sort bitvec 24
41 const 40 010110010100010101010011
42 uext 14 41 40
43 eq 1 16 42
44 ite 1 43 39 38
45 and 1 32 44
46 slice 17 12 7 0
47 slice 17 12 15 8
48 ite 17 9 47 46
49 slice 21 48 3 0
50 slice 21 48 7 4
51 ite 21 6 50 49
52 slice 25 51 1 0
53 slice 25 51 3 2
54 ite 25 4 53 52
55 slice 1 54 0 0
56 slice 1 54 1 1
57 ite 1 2 56 55
58 not 1 57
59 slice 25 12 1 0
60 slice 25 12 3 2
61 ite 25 4 60 59
62 slice 1 61 0 0
63 slice 1 61 1 1
64 ite 1 2 63 62
65 uext 14 41 40
66 eq 1 15 65
67 ite 1 66 39 64
68 and 1 58 67
69 and 1 57 8
70 or 1 68 69
71 and 1 31 70
72 or 1 45 71
73 output 72 COUT ; myCCU2C.v:18.28-18.32
74 uext 14 41 40
75 eq 1 15 74
76 ite 1 75 39 8
77 xor 1 57 76
78 output 77 S0 ; myCCU2C.v:18.20-18.22
79 uext 14 41 40
80 eq 1 16 79
81 ite 1 80 39 70
82 xor 1 31 81
83 output 82 S1 ; myCCU2C.v:18.24-18.26
84 uext 1 64 0 LUT2_0 ; myCCU2C.v:26.15-26.21
85 uext 1 38 0 LUT2_1 ; myCCU2C.v:37.15-37.21
86 uext 1 57 0 LUT4_0 ; myCCU2C.v:26.7-26.13
87 uext 1 31 0 LUT4_1 ; myCCU2C.v:37.7-37.13
88 uext 1 70 0 cout_0 ; myCCU2C.v:34.7-34.13
89 uext 1 76 0 gated_cin_0 ; myCCU2C.v:30.7-30.18
90 uext 1 81 0 gated_cin_1 ; myCCU2C.v:41.7-41.18
91 uext 1 67 0 gated_lut2_0 ; myCCU2C.v:33.7-33.19
92 uext 1 44 0 gated_lut2_1 ; myCCU2C.v:44.7-44.19
93 uext 1 2 0 lut2_0.A ; myCCU2C.v:28.9-28.62|myCCU2C.v:11.19-11.20
94 uext 1 4 0 lut2_0.B ; myCCU2C.v:28.9-28.62|myCCU2C.v:11.22-11.23
95 slice 21 12 3 0
96 uext 21 95 0 lut2_0.INIT ; myCCU2C.v:28.9-28.62|myCCU2C.v:12.16-12.20
97 uext 1 64 0 lut2_0.Z ; myCCU2C.v:28.9-28.62|myCCU2C.v:11.32-11.33
98 uext 25 61 0 lut2_0.s1 ; myCCU2C.v:28.9-28.62|myCCU2C.v:14.16-14.18
99 uext 1 3 0 lut2_1.A ; myCCU2C.v:39.9-39.62|myCCU2C.v:11.19-11.20
100 uext 1 5 0 lut2_1.B ; myCCU2C.v:39.9-39.62|myCCU2C.v:11.22-11.23
101 slice 21 13 3 0
102 uext 21 101 0 lut2_1.INIT ; myCCU2C.v:39.9-39.62|myCCU2C.v:12.16-12.20
103 uext 1 38 0 lut2_1.Z ; myCCU2C.v:39.9-39.62|myCCU2C.v:11.32-11.33
104 uext 25 35 0 lut2_1.s1 ; myCCU2C.v:39.9-39.62|myCCU2C.v:14.16-14.18
105 uext 1 2 0 lut4_0.A ; myCCU2C.v:27.9-27.73|myCCU2C.v:3.19-3.20
106 uext 1 4 0 lut4_0.B ; myCCU2C.v:27.9-27.73|myCCU2C.v:3.22-3.23
107 uext 1 6 0 lut4_0.C ; myCCU2C.v:27.9-27.73|myCCU2C.v:3.25-3.26
108 uext 1 9 0 lut4_0.D ; myCCU2C.v:27.9-27.73|myCCU2C.v:3.28-3.29
109 uext 11 12 0 lut4_0.INIT ; myCCU2C.v:27.9-27.73|myCCU2C.v:4.17-4.21
110 uext 1 57 0 lut4_0.Z ; myCCU2C.v:27.9-27.73|myCCU2C.v:3.38-3.39
111 uext 25 54 0 lut4_0.s1 ; myCCU2C.v:27.9-27.73|myCCU2C.v:8.16-8.18
112 uext 21 51 0 lut4_0.s2 ; myCCU2C.v:27.9-27.73|myCCU2C.v:7.16-7.18
113 uext 17 48 0 lut4_0.s3 ; myCCU2C.v:27.9-27.73|myCCU2C.v:6.16-6.18
114 uext 1 3 0 lut4_1.A ; myCCU2C.v:38.9-38.73|myCCU2C.v:3.19-3.20
115 uext 1 5 0 lut4_1.B ; myCCU2C.v:38.9-38.73|myCCU2C.v:3.22-3.23
116 uext 1 7 0 lut4_1.C ; myCCU2C.v:38.9-38.73|myCCU2C.v:3.25-3.26
117 uext 1 10 0 lut4_1.D ; myCCU2C.v:38.9-38.73|myCCU2C.v:3.28-3.29
118 uext 11 13 0 lut4_1.INIT ; myCCU2C.v:38.9-38.73|myCCU2C.v:4.17-4.21
119 uext 1 31 0 lut4_1.Z ; myCCU2C.v:38.9-38.73|myCCU2C.v:3.38-3.39
120 uext 25 28 0 lut4_1.s1 ; myCCU2C.v:38.9-38.73|myCCU2C.v:8.16-8.18
121 uext 21 24 0 lut4_1.s2 ; myCCU2C.v:38.9-38.73|myCCU2C.v:7.16-7.18
122 uext 17 20 0 lut4_1.s3 ; myCCU2C.v:38.9-38.73|myCCU2C.v:6.16-6.18
; end of yosys output
here-string-delimiter
        ;
        ))

     (match-define (hash-table ("S0" S0) ("S1" S1) ("COUT" COUT)) outs)

     (match-define (hash-table ("A0" A0)
                               ("A1" A1)
                               ("B0" B0)
                               ("B1" B1)
                               ("C0" C0)
                               ("C1" C1)
                               ("CIN" CIN)
                               ("D0" D0)
                               ("D1" D1)
                               ("INIT0" INIT0)
                               ("INIT1" INIT1)
                               ("INJECT1_0" INJECT1_0)
                               ("INJECT1_1" INJECT1_1))
       ins)

     (check-equal?
      (unsat)
      (verify (begin

                (assume (bvzero? INJECT1_0))
                (assume (bvzero? INJECT1_1))

                (match-define (list iS0 iS1 iCOUT)
                  (interpret `(lattice-ecp5-ccu2c ,INIT0
                                                  ,INIT1
                                                  ,(bv 0 1)
                                                  ,(bv 0 1)
                                                  ,CIN
                                                  ,(list (concat D0 C0 B0 A0) (concat D1 C1 B1 A1)))))
                (assert (bveq S0 iS0))
                (assert (bveq S1 iS1))
                (assert (bveq COUT iCOUT))))))))
