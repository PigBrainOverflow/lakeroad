#lang errortrace racket
;;; Utilities for .btor files.

(provide parse-btor)

(require rosette)

(define (parse-btor str)

  ;;; Maps ids (number) to bv expressions.
  (define h (make-hash))
  (define (get id)
    (hash-ref h id))
  (define (get-str id-str)
    (get (string->number id-str)))

  (define ins (make-hash))
  (define outs (make-hash))

  (for ([line (filter (lambda (line) (not (equal? #\; (string-ref line 0))))
                      (string-split str #rx"\n+"))])
    (match-let* ;;; Remove comments.
     ([line (first (string-split line ";"))] [(cons id-str tokens) (string-split line)]
                                             [id (string->number id-str)])
     (match tokens
       [`("sort" "bitvec" ,width-str) (hash-set! h id (bitvector (string->number width-str)))]
       [`("input" ,type-id-str ,name)
        (let* ([type (hash-ref h (string->number type-id-str))]
               [const (constant (string->symbol name) type)])
          (hash-set! ins name const)
          (hash-set! h id const))]
       [`("const" ,type-id-str ,value-str)
        (let* ([type (hash-ref h (string->number type-id-str))] [value (string->number value-str 2)])
          (hash-set! h id (bv value type)))]
       [`("ite" ,type-id-str ,cond-id-str ,true-val-id-str ,false-val-id-str)
        (hash-set! h
                   id
                   (if (bitvector->bool (get-str cond-id-str))
                       (get-str true-val-id-str)
                       (get-str false-val-id-str)))]
       [`("slice" ,type-id-str ,val-id-str ,u-str ,l-str)
        (hash-set! h id (extract (string->number u-str) (string->number l-str) (get-str val-id-str)))]
       [`("output" ,id-str ,name)
        (hash-set! outs name (get-str id-str))
        (hash-set! h id name)]
       [`("uext" ,out-type-id-str ,in-id-str "0" ,_ ...)
        (hash-set! h id (zero-extend (get-str in-id-str) (get-str out-type-id-str)))])))

  (list ins outs))

(module+ test
  (require rackunit
           "lut.rkt")

  (test-case
   "Parse a LUT4 and verify its implementation against our lut function."
   (begin
     (match-define (list ins outs)
       (parse-btor
        #<<here-string-delimiter
; BTOR description generated by Yosys 0.15+50 (git sha1 6318db615, x86_64-apple-darwin20.2-clang 10.0.0-4ubuntu1 -fPIC -Os) for module LUT4.
1 sort bitvec 1
2 input 1 A ; myLUT4.v:2.19-2.20
3 input 1 B ; myLUT4.v:2.22-2.23
4 input 1 C ; myLUT4.v:2.25-2.26
5 input 1 D ; myLUT4.v:2.28-2.29
6 sort bitvec 16
7 input 6 INIT ; myLUT4.v:3.17-3.21
8 sort bitvec 8
9 slice 8 7 7 0
10 slice 8 7 15 8
11 ite 8 5 10 9
12 sort bitvec 4
13 slice 12 11 3 0
14 slice 12 11 7 4
15 ite 12 4 14 13
16 sort bitvec 2
17 slice 16 15 1 0
18 slice 16 15 3 2
19 ite 16 3 18 17
20 slice 1 19 0 0
21 slice 1 19 1 1
22 ite 1 2 21 20
23 output 22 Z ; myLUT4.v:2.38-2.39
24 uext 16 19 0 s1 ; myLUT4.v:7.16-7.18
25 uext 12 15 0 s2 ; myLUT4.v:6.16-6.18
26 uext 8 11 0 s3 ; myLUT4.v:5.16-5.18
; end of yosys output
here-string-delimiter
        ;
        ))

     (define A (hash-ref ins "A"))
     (define B (hash-ref ins "B"))
     (define C (hash-ref ins "C"))
     (define D (hash-ref ins "D"))
     (define INIT (hash-ref ins "INIT"))

     ;;; Verify the parsed LUT4 against our implementation of LUT.
     (check-true (unsat? (verify (assert (bveq (hash-ref outs "Z") (lut INIT (concat D C B A))))))))))
